; Soft registers
DO_RESET        = $3FD
DO_SUSPEND      = $3FC
LinkSpeed       = $3FE
Simulation      = $3FF

Command          = $3F0
Command_DevEP    = $3F1
Command_Length   = $3F2
Command_MaxTrans = $3F3
Command_MemHi    = $3F4
Command_MemLo    = $3F5
Command_SplitCtl = $3F6
Command_Result   = $3F7

; Read registers
FILTERED_STAT_1 = $39
MEM_CTRL_READY  = $3D
DISCONNECTED    = $3E ; clear on write
STATUS          = $3F

; Write registers
SPEED                = $26

SET_DO_CHIRP         = $20
SET_CHIRP_LEVEL      = $21
SET_CONNECTED        = $22
SET_OPERATIONAL      = $23
SET_SUSPENDED        = $24
SET_SOF_ENABLE       = $27
CLR_DO_CHIRP         = $30
CLR_CHIRP_LEVEL      = $31
CLR_CONNECTED        = $32
CLR_OPERATIONAL      = $33
CLR_SUSPENDED        = $34
CLR_SOF_ENABLE       = $37

PULSE_WAKEUP         = $25
PULSE_RESET_FILTER   = $29

; Command interface to USB sequencer
CMD_REQUEST          = $60
CMD_DATA_BUFFER_CTRL = $61
CMD_DEVICE_ENDPOINT  = $62
CMD_SPLIT_CONTROL    = $63
CMD_RESPONSE         = $64

CMD_REQ_MEMREAD      = $8000
CMD_REQ_MEMWRITE     = $4000

CMD_NO_DATA          = $2000

CMD_RES_DATA         = $0000
CMD_RES_ACK          = $1000
CMD_RES_NAK          = $2000
CMD_RES_NYET         = $3000
CMD_RES_ERROR        = $4000
CMD_RES_MASK         = $7000
CMD_RES_NO_DATA      = $0400
CMD_RES_LEN_MASK     = $03FF

; Command interface to Memory Controller
MEM_ADDR_LO          = $70
MEM_ADDR_HI          = $71
MEM_TRANSFER_WRITE   = $72
MEM_TRANSFER_READ    = $73
MEM_BUFFER_INDEX     = $74

; Ulpi registers
ULPI_REG_READ_0      = $80
ULPI_REG_WRITE_0     = $C0
ULPI_R_IRQ_STATUS  = $93
ULPI_W_FUNC_CTRL   = $C4
ULPI_W_OTG_CONTROL = $CA


begin
    ; turn off power first
    LOAD  #$06
    OUTP  ULPI_W_OTG_CONTROL
    LOAD  #$45
    OUTP  ULPI_W_FUNC_CTRL
    OUTP  CLR_CONNECTED
    OUTP  CLR_OPERATIONAL
    OUTP  CLR_SUSPENDED
    OUTP  CLR_SOF_ENABLE
    LOAD  Simulation
    BEQ   start  ; Normal mode

    ; Simulation init
    LOAD  #$66
    OUTP  ULPI_W_OTG_CONTROL  ; turn on our power
_sim_restart
    OUTP  SET_CONNECTED
    CALL  _reset_end
    OUTP  SET_OPERATIONAL
    OUTP  SET_SOF_ENABLE

_waiting_for_reset_sim
    CALL  check_command
    LOAD  DO_RESET
    BEQ   _waiting_for_reset_sim
    LOAD  #0
    STORE DO_RESET
    OUTP  CLR_OPERATIONAL
    OUTP  CLR_SOF_ENABLE
    BRA   _sim_restart

start
    ; Turn off power and apply discharge
    LOAD  #$0E
    OUTP  ULPI_W_OTG_CONTROL
    BRA   _no_power
    
_startup_power_check    
    INP   ULPI_R_IRQ_STATUS
    AND   #6
    BEQ   _no_power
    ; power detected. Wait to see if discharging helps the power to disappear
    LOAD  #4000
    CALL  delay
    INP   ULPI_R_IRQ_STATUS
    AND   #2
    BEQ   _no_power

    ; still power detected, we should NOT turn on our power
    LOAD  #$06
    OUTP  ULPI_W_OTG_CONTROL
    BRA   _start2

_no_power
    LOAD  #$66
    OUTP  ULPI_W_OTG_CONTROL  ; turn on our power

_start2
    ; initialize our function control in FS mode, reset the transceivers and all
    LOAD  #$61
    OUTP  ULPI_W_FUNC_CTRL

    ; wait 700 ms for the power to get stable and all. a loop to check when the power is stable might be good here
    LOAD  ResetDelay
    CALL  delay
    
    ; now lets see if we can detect that there is a device already attached
    INP   STATUS
    AND   #3
    BNE   _device_detected ; one of the bits is '1', so someone is pulling it up

    OUTP  CLR_CONNECTED
_wait_for_device_attachment
    INP   STATUS
    AND   #3
    BEQ   _wait_for_device_attachment
    BRA   _start2

_device_detected
    SUB   #1
    XOR   #1
    OUTP  SPEED
    OUTP  DISCONNECTED
    OUTP  SET_CONNECTED
    
_waiting_for_reset
    CALL  check_disconnect
    BNE   _start2
    LOAD  DO_RESET
    BEQ   _waiting_for_reset

do_reset
    ; there is a device present. Let's reset it
    LOAD  #0
    STORE DO_RESET
    OUTP  CLR_SOF_ENABLE
    OUTP  CLR_OPERATIONAL
    CALL  bus_reset
    OUTP  CLR_SUSPENDED
    OUTP  SET_OPERATIONAL
    OUTP  SET_SOF_ENABLE
    LOAD  #2
    CALL  delay
    OUTP  DISCONNECTED
    BRA   main_loop

delay
    STORE DelayTimer
_delay
    CALL  loop_timer
    LOAD  DelayTimer
    SUB   #1
    STORE DelayTimer
    BNE   _delay
    RET    

check_disconnect
    INP   DISCONNECTED
    BPL   _no_disconnect
    OUTP  DISCONNECTED
    OUTP  CLR_CONNECTED
    OUTP  CLR_SOF_ENABLE
    OUTP  CLR_OPERATIONAL
_no_disconnect
    RET

main_loop
    CALL  check_disconnect
    BNE   _start2
    LOAD  DO_RESET
    BNE   do_reset
    LOAD  DO_SUSPEND
    BNE   do_suspend
    CALL  check_command
    BRA   main_loop

do_suspend
    OUTP  SET_SUSPENDED
    OUTP  CLR_SOF_ENABLE

; Set PHY in the right suspend state
    LOAD  LinkSpeed
    AND   #3
    ADD   #LinkRegisterMapSuspended
    STORE _reset_temp
    LOADI _reset_temp
    OUTP  ULPI_W_FUNC_CTRL

    LOAD  LinkSpeed
    CMP   #2
    BNE   suspend_loop
    LOAD  #1
    OUTP  SPEED  ; When we set the speed to 1 (HS), a different disconnect mechanism is selected.

    LOAD  #4000
    STORE _reset_temp
_do_suspend_1
    LOAD  _reset_temp
    BEQ   _device_suspended ; timeout, recovery will take place due to the fact that we think the device is disconnected
    SUB   #1
    STORE _reset_temp
    INP   STATUS
    AND   #3
    BNE   _device_suspended
    CALL  loop_timer
    BRA   _do_suspend_1

_device_suspended
    OUTP  DISCONNECTED
    
suspend_loop
    CALL  check_disconnect
    BNE   _start2
    LOAD  DO_RESET
    BNE   do_reset
    LOAD  DO_SUSPEND
    BEQ   do_unsuspend

_chk_remote_wakekup
    LOAD  LinkSpeed
    BNE   _chk_remote_wakeup_fs

_chk_remote_wakeup_ls
    INP   STATUS
    AND   #$03
    CMP   #1
    BNE   suspend_loop
    CALL  loop_timer
    INP   STATUS ; double check
    AND   #$03
    CMP   #1
    BNE   suspend_loop
    BRA   do_wakeup

_chk_remote_wakeup_fs
    INP   STATUS
    AND   #$03
    CMP   #2
    BNE   suspend_loop
    CALL  loop_timer
    INP   STATUS ; double check
    AND   #$03
    CMP   #2
    BNE   suspend_loop

do_wakeup
    OUTP  PULSE_WAKEUP
    
do_unsuspend
    OUTP  CLR_CHIRP_LEVEL
    ; Send K
    OUTP  SET_DO_CHIRP
    LOAD  #160
    CALL  delay
    OUTP  CLR_DO_CHIRP
    CALL  _reset_end     ; set the mode register correctly (this also resets the SPEED register to 2 for HS)
    LOAD  #32
_do_unsuspend_1
    SUB   #1
    BPL   _do_unsuspend_1
    OUTP  SET_SOF_ENABLE
    CALL  loop_timer
    CALL  loop_timer
    OUTP  CLR_SUSPENDED
    BRA   main_loop
    
; The following code issues a reset, and tries to get the device in high speed mode

bus_reset
    ; first we check the current status of the bus power.
;    INP   STATUS
;    AND   #$38 ; 3C
;    CMP   #$08 ; 0C
;    BEQ   _reset_chk_ls
;    LOAD  #3
;    STORE LinkSpeed
;    BRA _reset_end
;
_reset_chk_ls
    INP   STATUS
    AND   #$02
    BEQ   _reset_fs
    LOAD  #0
    STORE LinkSpeed
    BRA   _do_reset
_reset_fs
    LOAD  #1
    STORE LinkSpeed

_do_reset
; now we set up the ULPI register to output single ended zero.
    LOAD  #$50
    OUTP  ULPI_W_FUNC_CTRL

    LOAD  #120
    STORE ResetTimer
    OUTP  PULSE_RESET_FILTER
    OUTP  FILTERED_STAT_1
    
    LOAD  LinkSpeed
    BEQ   _reset_simple

_reset_1
    INP   FILTERED_STAT_1
    BMI   _reset_chirp_heard
    CALL  loop_timer
    LOAD  ResetTimer
    SUB   #1
    STORE ResetTimer
    BNE   _reset_1
_reset_end
    LOAD  LinkSpeed
    OUTP  SPEED
    AND   #3
    ADD   #LinkRegisterMap
    STORE _reset_temp
    LOADI _reset_temp
    OUTP  ULPI_W_FUNC_CTRL
    OUTP  DISCONNECTED
    RET
_reset_temp
    .dw 0
_reset_chirp_heard    
    LOAD  #2
    STORE LinkSpeed
    ; Just go ahead and send our chirp back
    OUTP  CLR_CHIRP_LEVEL
    OUTP  SET_DO_CHIRP
    LOAD  NumberOfChirps
    STORE ResetTimer
_chirp_loop
    OUTP  CLR_CHIRP_LEVEL
    LOAD  #750
_chirp_k
    SUB   #1
    BNE   _chirp_k
    LOAD  ResetTimer
    SUB   #1
    STORE ResetTimer
    BEQ   _chirps_done
    OUTP  SET_CHIRP_LEVEL
    LOAD  #750
_chirp_j
    SUB   #1
    BNE   _chirp_j
    BRA   _chirp_loop
; done chirping
_chirps_done
    OUTP  CLR_DO_CHIRP
    LOAD  #3
    STORE ResetTimer
_reset_simple
    CALL  loop_timer
    LOAD  ResetTimer
    SUB   #1
    STORE ResetTimer
    BNE   _reset_simple
    BRA   _reset_end

loop_timer
    LOAD  #1873
_loop_timer_1
    SUB   #1
    BPL   _loop_timer_1
    RET

temp
    .dw 0

ResetTimer
DelayTimer
    .dw 0

LinkRegisterMap
    .dw $46
    .dw $45
    .dw $40
    .dw $50

LinkRegisterMapSuspended
    .dw $56
    .dw $55
    .dw $55
    .dw $50

ResetDelay
    .dw 5600
NumberOfChirps
    .dw 75

; Command        = $3F0
; Command_DevEP  = $3F1
; Command_Length = $3F2
; Command_MaxTrans = $3F3
; Command_MemHi  = $3F4
; Command_MemLo  = $3F5
; Command_SplitCtl = $3F6
; Command_Result   = $3F7

check_command
    LOAD Command
    BNE  _parse_cmd
    RET ; zero = no command

_parse_cmd
    LOAD Command_MemHi
    OUTP MEM_ADDR_HI
    LOAD Command_MemLo
    OUTP MEM_ADDR_LO
    LOAD Command_DevEP
    OUTP CMD_DEVICE_ENDPOINT

    LOAD Command
    BMI  _out_command

; If we get here, we assume that it is an IN command
_next_in_chunk
    LOAD CurrentBuffer
    OUTP CMD_DATA_BUFFER_CTRL
    LOAD Command
    OUTP CMD_REQUEST ; Do it!!
_wait_in_cmd
    INP  CMD_RESPONSE
    BPL  _wait_in_cmd
    STORE Command_Result
    AND  #CMD_RES_MASK
    CMP  #CMD_RES_DATA
    BEQ  _in_success
    BRA  _done ; for now, we just break on anything else than DATA

_in_success
    LOAD Command_Result
    AND  #CMD_RES_LEN_MASK
    STORE CurrentLength

_check_rx_toggle
    LOAD Command
    XOR  Command_Result
    AND  #$800 ; toggle bit
    BEQ  _toggle_ok
    LOAD #0
    STORE CurrentLength

_toggle_ok
    LOAD Command
    AND  #CMD_REQ_MEMWRITE
    BEQ  _no_mem_write

_wait_mem2
    INP  MEM_CTRL_READY
    BPL  _wait_mem2

    LOAD CurrentBuffer
    OUTP MEM_BUFFER_INDEX
    LOAD CurrentLength
    BEQ  _no_mem_write
    ADD  #3
    OUTP MEM_TRANSFER_WRITE     
    
_no_mem_write
    LOAD  Command
    XOR   #$800 ; togglebit
    STORE Command

    LOAD  CurrentBuffer
    ADD   #$4000
    STORE CurrentBuffer

    LOAD Command_Length
    SUB  CurrentLength
    STORE Command_Length
    BEQ  _done
    BMI  _done
    LOAD CurrentLength
    CMP  Command_MaxTrans
    BPL  _next_in_chunk
    
_done
    INP  MEM_CTRL_READY
    BPL  _done
    LOAD #0
    STORE Command
    RET
    
do_mem_read
    LOAD CurrentBuffer
    OUTP MEM_BUFFER_INDEX
    CALL determine_length
    ADD  #3
    OUTP MEM_TRANSFER_READ
    RET

        
_out_command
    CALL do_mem_read ; first time
_next_out_chunk
    LOAD CurrentLength
    BNE  _has_data
    OR   #CMD_NO_DATA
_has_data
    OR   CurrentBuffer
    OUTP CMD_DATA_BUFFER_CTRL

_wait_mem1
    INP  MEM_CTRL_READY
    BPL  _wait_mem1

    LOAD Command
    OUTP CMD_REQUEST ; Do it!!

    ; Next buffer, lets see if we need to read more
    LOAD  CurrentBuffer
    ADD   #$4000
    STORE CurrentBuffer

    LOAD  Command
    XOR   #$800 ; togglebit
    STORE Command

    LOAD Command_Length
    SUB  CurrentLength
    STORE Command_Length
    BEQ  _out_done

    CALL do_mem_read ; second and subsequent times

_wait_out_cmd
    INP  CMD_RESPONSE
    BPL  _wait_out_cmd
    STORE Command_Result
    AND  #CMD_RES_MASK
    CMP  #CMD_RES_ACK
    BNE  _done ; for now, we just break on anything else than ACK

    BRA  _next_out_chunk

_out_done
    INP  CMD_RESPONSE
    BPL  _out_done
    STORE Command_Result
    LOAD #0
    STORE Command
    RET

determine_length
    LOAD Command_Length
    CMP  Command_MaxTrans
    BMI  _no_truncate
    LOAD Command_MaxTrans
_no_truncate
    STORE CurrentLength
    RET

CurrentLength
    .dw 0
CurrentBuffer
    .dw 0
